Solutions for the detailed JavaScript and TypeScript course. Tasks description can be found below.


**warmup.js**

A + B problem - Функция, которая вычисляет сумму двух чисел.
Century by year problem - Функция, которая определяет век по году.
Colors problem - Функция, которая переводит цвет из формата HEX в формат RGB.
Fibonacci problem - Функция, которая вычисляет n-ое число Фибоначчи.
Matrix problem - Функция, которая транспонирует матрицу, представленную в виде двумерного массива.
Number system problem - Функция, которая переводит число в нужную систему счисления.
Phone problem - Функция, которая проверяет, соответствует ли номер телефона формату 8–800–xxx–xx–xx.
Smiles problem - Функция, которая подсчитывает количество улыбающихся смайликов в строке, представленных в виде :-) или (-:.
Tic tac toe problem - Функция, которая определяет результат в игре "крестики-нолики".


**phone.js**

Общеизвестный SQL использует английский язык, а Аркадий и Василиса говорят на русском. Так появился язык, который Аркадий назвал pbQL (Phone Book Query Language).
Аркадий придумал спецификацию pbQL, а за первой реализацией обратился к вам.

Синтаксис языка pbQL
Язык состоит из нескольких команд:

Создай контакт <имя>
Создает новый контакт с именем <имя> с пустыми списками телефонов и почт
Принимает <имя> содержащее любые символы, кроме ;    ,Не создает ничего, если контакт уже существует
Пример: Создай контакт Григорий;

Удали контакт <имя>
Удаляет контакт с именем <имя>, Принимает <имя> содержащее любые символы, кроме ;    ,Не удаляет ничего, если контакт не существует
Пример: Удали контакт Григорий;

Добавь телефон <телефон> и почту <почта> для контакта <имя>
Добавляет <телефон> в спискок телефонов и <почту> в список почт для контакта <имя>
Принимает телефоны только в формате 5556667788 (без кода), иначе это считается ошибкой синтаксиса
Принимает почты без пробелов, поэтому через пробел ожидается следующее слово
Принимает произвольное количество почт и телефонов, перечисленных через и
Не добавляет ничего, если контакт не существует
Не добавляет почту/телефон, если такая почта/телефон уже есть у контакта
Пример: Добавь телефон 5556667788 и телефон 5556667787 и почту grisha@example.com для контакта Григорий;

Удали телефон <телефон> и почту <почта> для контакта <имя>
Удаляет <телефон> из списка телефонов и <почту> из списка почт контакта <имя>, Принимает телефоны только в формате 5556667788 (без кода), иначе это считается ошибкой синтаксиса
Принимает почты без пробелов, иначе это считается ошибкой синтаксиса, Принимает произвольное количество почт и телефонов, перечисленных через и
Не удаляет ничего, если контакт не существует, Не удаляет почту/телефон, если такая почта/телефон отсутствует у контакта
Пример: Удали телефон 5556667788 для контакта Григорий;

Покажи почты и телефоны для контактов, где есть <запрос>
Ищет вхождение <запрос> хотя бы в один из телефонов, либо в одну из почт, либо в имя контакта, Принимает <запрос> содержащий любые символы, кроме ;
Принимает для перечисления произвольное количество типов полей, перечисленных через и, среди которых могут быть имя, почты и телефоны
Возвращает список строк в формате <почта 1>,<почта 2>;<телефон 1> в соответствии с запращиваемыми полями, для подходящих под запрос контактов, Возвращает контакты в порядке создания, а их почты/телефоны в порядке добавления
Возвращает имена и электронные почты как есть, а телефоны в виде +7 (555) 666-77-88, Не возвращает ничего на пустой запрос (Покажи имя для контактов, где есть ;)
Пример: Покажи имя и почты и телефоны и почты для контактов, где есть Гр;

Удали контакты, где есть <запрос>
Ищет вхождение <запрос> хотя бы в один из телефонов, либо в одну из почт, либо в имя контакта, Принимает <запрос> содержащий любые символы, кроме ;
Удаляет все подходящие контакты, Не удаляет ничего на пустой запрос (Удали контакты, где есть ;)
Пример: Удали контакты, где есть Гр;


**friends.js**

Три компаньона Аркадия – «Danny», «Rusty» и «Linus» – частенько проворачивают тёмные делишки под покровом ночи: пишут на PHP, едят после шести и изредка грабят банки.
Сегодня они подумали, что настало время завязать с тёмными делами. Поэтому решили пойти на последнее ограбление, а после изучить JavaScript и стать законопослушными фронтедерами.
Сейчас уже понедельник, а в четверг в последний банк поставят новую сигнализацию. И у них есть только три дня (понедельник, вторник и среда), чтобы выбрать подходящее время. Во-первых, это должно быть в рабочие часы банка – так легче проникнуть в него.
Во-вторых, все трое должны быть свободны.И в-третьих, должно быть достаточно времени, чтобы провернуть дело.
Компаньоны быстро составили расписание – когда и кто занят(заметьте, что грабители находятся в разных часовых поясах):
{
    "Danny": [
        { "from": "ПН 12:00+5", "to": "ПН 17:00+5" },
        { "from": "ВТ 13:00+5", "to": "ВТ 16:00+5" }
    ],
    "Rusty": [
        { "from": "ПН 11:30+5", "to": "ПН 16:30+5" },
        { "from": "ВТ 13:00+5", "to": "ВТ 16:00+5" }
    ],
    "Linus": [
        { "from": "ПН 09:00+3", "to": "ПН 14:00+3" },
        { "from": "ПН 21:00+3", "to": "ВТ 09:30+3" },
        { "from": "СР 09:30+3", "to": "СР 15:00+3" }
    ]
}
И нашли в интернете часы работы банка: { "from": "10:00+5", "to": "18:00+5" }
Но выбрать время для ограбления с ходу не получилось, поэтому предлагаем вам написать код с методом (getAppropriateMoment), который на вход принимает расписание (schedule), необходимое для ограбления время (time) в минутах и время работы банка (workingHours), вычисляет подходящее время и на выходе предоставляет объект для работы с ним:
.exists() – отвечает на вопрос найдено ли время вообще
.format(template) – выводит время ограбления в часовом поясе банка и согласно переданному шаблону, который может включать в себя часы HH, минуты MM и день недели DD. Например, «Начинаем в %HH:%MM (%DD)». Если время не найдено, метод возвращает пустую строку.


**lecture.js**

После криминальной интриги с участием друзей Аркадий возвращается в мрачные стены университета — время слушать лекцию и впитывать новые знания.

Вас ждут студенты, готовые внимать каждому слову преподавателя:

const students = {
  Sam: {
    focus: 100,
    wisdom: 50
  },
  Daria: {
    focus: 100,
    wisdom: 60
  }
};
И преподаватель Сергей, который вот-вот начнёт лекцию и покажет первый слайд с бесценной информацией.

lecturer.on('begin', students.Sam, function() {
  // Внимательно слушаем преподователя
  this.focus += 10;
});

lecturer.on('slide', students.Daria, function() {
  // И впитываем мудрость с каждым слайдом
  this.wisdom += 10;
});
Студента можно подписать на событие, производимое преподавателем (например, начало лекции или показ нового слайда) — то есть указать, какая функция должна быть вызвана при наступлении этого события.

Ваша задача — реализовать несколько методов:

подписка на событие — on;
отписка от события — off;
вызов события — emit.
Чтобы задание не казалось совсем простым, вам также нужно реализовать поддержку пространства имён для событий.

// ...

lecturer.on('slide', students.Sam, function() {
  // И впитываем мудрость с каждым слайдом
  this.wisdom += 10;
});

lecturer.on('slide.funny', students.Sam, function() {
  this.wisdom -= 5;
});


**wedding.js**

Как-то на одной из лекций Аркадий познакомился с девушкой и в скором времени его корабль, под названием «Любовь», наконец-то готов пришвартоваться в бухте, под названием «Семья». Настало время организовать весёлую свадьбу.
Для этого, по мнению Аркадия, должен быть соблюдён ряд условий:
Во-первых, на свадьбе должны быть не только друзья, но и друзья друзей. Во-вторых, слишком незнакомые парни смущают Аркадия и он планирует ограничить уровень неизвестности определённым кругом
В-третьих, чтобы никому не было грустно – он их собирает в пары «парень + девушка»
Аркадий вновь достаёт свою телефонную книгу с записями о друзьях и дополняет её информацией о том, кто и с кем дружит (friends), и кто является его лучшими друзьями (best) таким образом:
const friends = [
    {
        name: 'Sam',
        friends: ['Mat', 'Sharon'],
        gender: 'male',
        best: true
    },
    {
        name: 'Sally',
        friends: ['Brad', 'Emily'],
        gender: 'female',
        best: false
    }
];
И чтобы помочь Аркадию выбрать кого пригласить необходимо подготовить для него удобные фильтры и итераторы для работы с телефонной книгой.
// Создаем фильтры парней и девушек
const maleFilter = new lib.MaleFilter();
const femaleFilter = new lib.FemaleFilter();
// Создаем итераторы
const femaleIterator = new lib.Iterator(friends, femaleFilter);
// Среди парней приглашаем только луших друзей и друзей лучших друзей
const maleIterator = new lib.LimitedIterator(friends, maleFilter, 2);
const invitedFriends = [];
// Собираем пары «парень + девушка»
while (!maleIterator.done() && !femaleIterator.done()) {
    invitedFriends.push([
        maleIterator.next(),
        femaleIterator.next()
    ]);
}
// Если остались девушки, то приглашаем остальных
while (!femaleIterator.done()) {
    invitedFriends.push(femaleIterator.next());
}
Мы выложили пример того как можно работать с вашим кодом под условием задачи, а заготовку для того чтобы реализовать свой код вы можете найти здесь.

Общие условия:
⚠️ Код необходимо написать в интерфейсах, зафиксированных в заготовке. То есть использовать функции-конструкторы и методы работы с прототипами, и не использовать «классы».
Лучшие друзья помечены флагом best
Для каждого друга указан список его друзей
Дружба всегда взаимная
Обход должен происходить, начиная с лучших друзей
Обход всегда идет в алфавитном порядке имен
Друзья не должны обходиться дважды
Первый круг друзей – это лучшие друзья
Второй круг друзей – это друзья лучших друзей
Третий круг и остальные строятся аналогичным образом
Гарантируется, что на входе будут корректные условия
Неориентированный граф друзей
Все перечисленные друзья в свойствах friends будут существовать во входном массиве
Граф друзей может быть несвязным и/или цикличным

Условия для LimitedIterator
Наследник Iterator. Имеет ограничение по кругу maxLevel. Если передан maxLevel равен 1, то итератор обойдет только первый круг друзей, если 2 – первый и второй. И так далее.

Условия для Filter
Создает фильтр, который решает какой друг подходит для итерации. По умолчанию такой фильтр никого не отсеивает

Условия для MaleFilter
Наследник Filter. Позволяет итерироваться по друзьям мужского пола

Условия для FemaleFilter
Наследник Filter. Позволяет итерироваться по друзьям женского пола


**adventure.js**

Свадьба Аркадия сыграна, торт съеден, гости проводили молодоженов в их новую семейную жизнь. Что же дальше? А дальше наша молодая пара планирует свое свадебное путешествие. Прагматичный Аркадий посчитал важным заранее продумать свадебное путешествие, чтобы оно было максимально комфортным.
Аркадий едет в свадебное путешествие не только со своей возлюбленной супругой, но и с личным фотографом, поэтому перед нашим программистом-прагматиком стоит не менее прагматичная задача: составить расписание маршрута так, чтобы можно было сделать фотографии с разными погодными условиями в разных городах.
Для того чтобы достичь желаемого, Аркадий решил написать приложение, которое не уступит по своей красоте, простоте и удобству даже Кибертраку Илона Маска. Аркадий слышал, что у Яндекс.Погоды есть удобное API для получения прогноза погоды. Им он и решил воспользоваться в своем приложении.
Аркадию, как известному эстету, хотелось сделать свою библиотеку простой и удобной:

const availableGeoIds = [5, 10, 192, 20, 37];
const sunnyPlan = planTrip(availableGeoIds)
  .sunny(2)
  .cloudy(1)
  .sunny(2)
  .max(3)
  .build();
const cloudyPlan = planTrip(availableGeoIds)
  .cloudy(2)
  .sunny(1)
  .build();
Можно считать, что все города, которые будут передаваться в метод planTrip, расположены между собой на расстоянии, которое Аркадий может преодолеть меньше, чем за половину суток, поэтому про расстояния в рамках данного задания можно забыть. Путешествие начинает свой отсчёт с одного из городов из списка.

Методы-условия
Методы cloudy, sunny, max добавляют условия для будущего путешествия. Они принимают параметр — число дней, в течении которого должно соблюдаться заданное методом условие.
sunny(N) — Солнечная погода N дней. Для API Яндекс.Погоды — это значения condition равные clear и partly-cloud
cloudy(N) — Полная облачность N дней. Для API Яндекс.Погоды — это значения condition равные cloudy и overcast
max(M) — Максимальное количество дней, в котором молодожены хотят быть в одном городе
Для соблюдения условий Аркадий может переместиться в другой город или же остаться в предыдущем городе путешествия. Аркадий с женой очень любят изучать города, по которым путешествуют очень внимательно, поэтому строят маршрут так, чтобы максимальное количество дней побыть в одном городе.

API планировщика
Метод build() инициирует построение маршрута и возвращает Promise с ответом.
Если маршрут по указанным условиям сформировать возможно, то ответом будет массив вида [ { geoid: 1, day: 1 } ], где day – день поездки (начиная с 1).
Если по указанным условиям маршрут построить невозможно, метод build() возвращает Promise, который переходит в состояние rejected с ошибкой и сообщением: Не могу построить маршрут!.

Библиотека для HTTP запросов
В браузер уже встроена глобально доступная функция fetch (она же window.fetch), которая позволяет удобно делать HTTP запросы.
Мы работаем в Node.js окружении и в неё встроены низкоуровневые модули http, https, http2. Они гораздо менее удобные, чем fetch. Предлагаем вам в решении домашнего задания воспользоваться библиотекой node-fetch, которая почти полностью повторяет браузерный аналог. Мы уже установили её для вас.
API Яндекс.Погоды
Для получения прогноза погода на ближайшие семь дней можно обратиться к данному методу API, заменяя лишь параметр geoid на необходимый. За документацией ответа можно обратиться на эту страницу. Для обращения к API вам понадобится получить ключ для тарифа "Тестовый". Положите полученный ключ в файл key.json, чтобы не отправлять ваш секретный ключ вместе с решением. Прогнозом на сутки для города следует считать прогноз в графе day_short.
